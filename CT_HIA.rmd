---
title: "Health Impact Assessment of Affordable Housing Development in Connecticut"
output:
  html_document:
    df_print: paged
---

```{r load packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(here)
library(readxl)
library(ncdf4)
#library(raster)
#library(rgeos)
#library(rgdal)
library(tidycensus)
library(daymetr)
```

```{r load pollutant datasets}
# read in PM2.5 daily average by census tract from EPA FAQSD
pm_tract <- read.delim(gzfile("2019_pm25_daily_average.txt.gz"), sep = ",") %>%
## include only Connecticut tracts - FIPS starting with 9
  filter(str_detect(`FIPS`, "^9")) %>% 
## include only index date - July 4, 2019
  filter(`Date` == "2019/07/04") %>% 
## format FIPS to match GEOID format used by tidycensus get_acs
  mutate(GEOID = str_pad(FIPS, 11, side = "left", pad = "0"))

# read in ozone daily 8-hour maximum by census tract from EPA FAQSD
o3_tract <- read.delim(gzfile("2019_ozone_daily_8hour_maximum.txt.gz"), sep = ",") %>%
## include only Connecticut tracts - FIPS starting with 9
  filter(str_detect(`FIPS`, "^9")) %>% 
## include only index date - July 4, 2019
  filter(`Date` == "2019/07/04") %>% 
## format FIPS to match GEOID format used by tidycensus get_acs
  mutate(GEOID = str_pad(FIPS, 11, side = "left", pad = "0"))

no2 <- nc_open("SurfaceNO2_0.0083deg_2019.nc")

```

```{r load affordable housing dataset}
# read housing data from CT Open Data
housing_town <- read.csv("Affordable_Housing_by_Town_2011-2022.csv") %>% 
  filter(`Year` == 2019) %>% 
  mutate(`At least 10%?` = cut(`Percent.Affordable`, breaks = c(0,9.99999,100),
  labels = c("No", "Yes"))) %>% 
  rename("TOWN_NAME" = "Town") %>% 
  mutate(`Units Needed` = ceiling((1-(`Percent.Affordable`/10))*`X2010.Census.Units`*(1/9)))

# set units needed to 0 for towns already at or above 10% threshold
housing_town$`Units Needed`[housing_town$`At least 10%` == "Yes"] = 0
```

```{r load incidence datasets}
# read county-level all-cause mortality rates from CDC WONDER
allcause <- read.delim("Underlying Cause of Death, 2018-2021, Single Race_STATE.txt", sep = "\t")[1:2,-1]
```

```{r get list of ACS variables}
# list of 5-year ACS variables for reference
vars <- load_variables(year = 2019, dataset = "acs5", cache = TRUE)
```

```{r load shapefiles and population data for CT census tracts}
options(tigris_use_cache = TRUE)

# get CT census tract polygon using variable for families in poverty
ct_tracts <- get_acs(state = "CT", geography = "tract", variables = "B17013_002", geometry = TRUE, year = 2019) %>% 
## join PM2.5 data
  left_join(., pm_tract, by = "GEOID") %>% 
## join ozone data
  left_join(., o3_tract, by = "GEOID")

# get estimates of households in each income bracket by town
township_incomes <- get_acs(geography = "county subdivision", state = "CT", table = "B19001", year = 2019, output = "tidy")

# pull low-income limits by town
AMI_limits <- read_excel(here("Section8-FY19.xlsx")) %>% 
  filter(state_name == "Connecticut") %>% 
  select(GEOID = fips2010, TOWN_NAME = county_town_name, limit = l80_4)

# merge township data
township_data <- left_join(AMI_limits, township_incomes, by = "GEOID") %>% 
  # clean town name
  mutate(TOWN_NAME = str_sub(TOWN_NAME, 1, nchar(TOWN_NAME) - 5))

# merge maximum incomes for each bracket with township data 
variable <- c("B19001_002", "B19001_003", "B19001_004", "B19001_005", "B19001_006", "B19001_007", "B19001_008", "B19001_009", "B19001_010", "B19001_011", "B19001_012", "B19001_013", "B19001_014", "B19001_015", "B19001_016", "B19001_017")
max_income <- c(9999, 14999, 19999, 24999, 29999, 34999, 39999, 44999, 49999, 59999, 74999, 99999, 124999, 149999, 199999, 200000)
income_brackets <- data.frame(variable, max_income)
low_income <- left_join(income_brackets, township_data, by = "variable")

# sum to find total low-income households (at or below 80% AMI)
low_income_pop <- low_income %>% 
  mutate(below_ami = case_when(max_income <= limit ~ estimate, max_income > limit ~ 0)) %>% 
  group_by(TOWN_NAME) %>% 
  summarize(total_at_or_below_ami = sum(below_ami)) %>% 
  # join housing by town
  left_join(housing_town, by = "TOWN_NAME") %>% 
  select(TOWN_NAME, total_at_or_below_ami, `Units Needed`)
```

```{r load shapefiles for CT townships}
# read CT town lines
town_lines <- st_read("CT Town Lines/Town_Lines.shp")

# read CT town polygon
town_poly <- st_read("CT Vicinity Town Polygon/CT_Vicinity_Town_Polygon.shp") %>%
  filter(STATE_COD == "CT", is.na(TOWN_NAME) == FALSE) 

town_polygon <- town_poly %>% 
  # join housing data by town - using inner join to exclude area of Long Island Sound
  inner_join(housing_town, by = "TOWN_NAME") %>% 
  #join population with low income by town
  left_join(low_income_pop, by = "TOWN_NAME")
```

```{r aggregate tract-level exposures by township}
# using spreadsheet from 2010 census tract to town conversion tool from CT Data Collaborative: https://tract2town.ctdata.org/
tract_town <- read.csv("Census_Tracts_with_Town_Names__2010_.csv") %>% 
## join families by tract to towns by tract
  mutate(GEOID = str_pad(GEOID, 11, side = "left", pad = "0")) %>% 
  select(GEOID, TOWN_NAME = Town) %>% 
## clean rows - delete undefined township, for now keeping rows with no exposure data (East Lyme, Wolcott)
  filter(TOWN_NAME != "County subdivisions not defined")

## clean rows - assign tracts with multiple towns and 0 families to one town
tract_town$TOWN_NAME[tract_town$TOWN_NAME == "East Granby, Windsor Locks, Suffield"] <- "East Granby"
tract_town$TOWN_NAME[tract_town$TOWN_NAME == "Groton, Ledyard"] <- "Groton"
tract_town$TOWN_NAME[tract_town$TOWN_NAME == "Norwalk, Darien, Greenwich, Stamford, Westport"] <- "Norwalk"

## assigning Union township to only tract containing Union
tract_town$TOWN_NAME[tract_town$TOWN_NAME == "Stafford, Union"] <- "Union" 

## splitting "Canaan, Norfolk" tract among both towns since both are only found in this tract
tract_town <- tract_town %>% bind_rows(slice(., which(tract_town$TOWN_NAME == "Canaan, Norfolk"))) 
tract_town$TOWN_NAME[tract_town$TOWN_NAME == "Canaan, Norfolk"] <- "Canaan"
tract_town$TOWN_NAME[nrow(tract_town)] <- "Norfolk"

# summarize mean PM2.5 and standard deviation of tract-level estimates by town
pm_town <- tract_town %>%
  right_join(pm_tract, by = "GEOID") %>%
  group_by(`TOWN_NAME`) %>% 
  summarize(pm_mean = mean(`pm25_daily_average.ug.m3.`, na.rm = TRUE), `Standard Deviation (ug/m3)` = sd(`pm25_daily_average.ug.m3.`, na.rm = TRUE), `Min` = min(`pm25_daily_average.ug.m3.`, na.rm = TRUE), `Max` = max(`pm25_daily_average.ug.m3.`, na.rm = TRUE), `IQR (ug/m3)` = IQR(`pm25_daily_average.ug.m3.`, na.rm = TRUE))

# summarize mean and standard deviation of tract-level ozone estimates by town
o3_town <- tract_town %>%
  right_join(o3_tract, by = "GEOID") %>%
  group_by(`TOWN_NAME`) %>% 
  summarize(o3_mean = mean(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE), `Standard Deviation (ppb)` = sd(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE), `Min O3` = min(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE), `Max O3` = max(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE), `IQR (ppb)` = IQR(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE)) 

# join to town polygon
pm_town_sf <- town_polygon %>% 
  left_join(pm_town, by = "TOWN_NAME")

o3_town_sf <- town_polygon %>% 
  left_join(o3_town, by = "TOWN_NAME")
```

```{r map exposure contrast within townships}
# map PM2.5 standard deviation by town
ggplot() + geom_sf(data = pm_town_sf, aes(fill = `Standard Deviation (ug/m3)`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map ozone standard deviation by town
ggplot() + geom_sf(data = o3_town_sf, aes(fill = `Standard Deviation (ppb)`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map PM2.5 standard error by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = pm25_daily_average_stderr.ug.m3.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map ozone standard error by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = ozone_daily_8hour_maximum_stderr.ppb.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map PM2.5 standard deviation by town
ggplot() + geom_sf(data = pm_town_sf, aes(fill = `IQR (ug/m3)`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map ozone standard deviation by town
ggplot() + geom_sf(data = o3_town_sf, aes(fill = `IQR (ppb)`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)
```

```{r map baseline pollution by census tract}
# map PM2.5 by census tract without town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = pm25_daily_average.ug.m3.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map PM2.5 by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = pm25_daily_average.ug.m3.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map O3 by census tract without town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = ozone_daily_8hour_maximum.ppb.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map O3 by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = ozone_daily_8hour_maximum.ppb.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map temperature by census tract

```

```{r map baseline housing by township}
# map percent of affordable housing units by town
ggplot() + geom_sf(data = town_polygon, aes(fill = `Percent.Affordable`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map 8-30g exemptions by town
ggplot() + geom_sf(data = town_polygon, aes(fill = `At least 10%?`))
```

```{r map baseline population by census tract}
# map families below poverty level by census tract - previous estimate used
ggplot() + geom_sf(data = ct_tracts, aes(fill = estimate)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map low-income population by census tract - new estimate used
ggplot() + geom_sf(data = town_polygon, aes(fill = total_at_or_below_ami)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)
```

```{r map baseline pollution by township}
# map PM2.5 by town
ggplot() + geom_sf(data = pm_town_sf, aes(fill = pm_mean)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)
```

# Simulate movement into new housing with inverse distance weighting penalty

```{r simulate movement of families, warning=FALSE}
#load population-weighted centroids


#find centroids for largest polygon per town
centroids <- town_poly %>%
  st_centroid() %>% 
  group_by(TOWN_NAME) %>% 
  slice_max(order_by = SHAPE_Area)

#assign weights to each pair of towns equal to inverse distance squared
  #list every town pair
weights <- data.frame(moved_from = rep(centroids$TOWN_NAME, times = nrow(centroids))) %>% 
  mutate(moved_to = rep(centroids$TOWN_NAME, times = rep(nrow(centroids), nrow(centroids)))) %>%
  #create columns for pre- and post-move town centroids
  mutate(centr_from = rep(centroids$geometry, times = nrow(centroids))) %>% 
  mutate(centr_to = rep(centroids$geometry, times = rep(nrow(centroids), nrow(centroids)))) %>% 
  #calculate distances between centroids
  mutate(distance = st_distance(centr_from, centr_to, by_element = TRUE)) %>% 
  mutate(distance = as.numeric(distance))

dist_0 <- weights %>% 
  filter(moved_from == moved_to) %>% 
  select(moved_from, moved_to)

for(i in 1:nrow(dist_0)) {
  dist_0$replace[i] <- town_poly %>% 
    group_by(TOWN_NAME) %>% 
    slice_max(order_by = SHAPE_Area) %>% 
    filter(TOWN_NAME == dist_0$moved_from[i]) %>% 
    st_convex_hull() %>% 
    st_cast("MULTIPOINT") %>%
    st_cast("POINT") %>%
    st_distance() %>%
    #find max distance between any two points on town boundary and divide by two
    max(na.rm = TRUE)/2
}

#select columns from low_income_pop to join with weights
families_pre_town <- low_income_pop %>% 
  select(moved_from = TOWN_NAME, total_at_or_below_ami) 
dev_town <- low_income_pop %>% 
  select(moved_to = `TOWN_NAME`, `Units Needed`)

#set seed for reproducible samples  
set.seed(99814)

#old method
weights0 <- weights %>%
  left_join(families_pre_town, by = "moved_from") %>% 
  left_join(dev_town, by = "moved_to") %>% 
  left_join(dist_0, by = c("moved_from", "moved_to")) %>% 
  #replace zero-length distances with replacements (half of max distance w/in town)
  mutate(dist_new = if_else(distance == 0, replace, distance)) %>% 
  #group by town pre-move
  group_by(moved_from) %>% 
  #round up units to integer
  mutate(prop_units = `Units Needed`/sum(`Units Needed`)) %>%
  #take inverse of distance squared
  mutate(inv_sq = 1/dist_new^2) %>% 
  #calculate crude penalty using families (pre-move town), proportion of new units (post-move town), and inverse distance squared (town pair)
  mutate(penalty = prop_units*inv_sq) %>% 
  mutate(lambda = total_at_or_below_ami*penalty/sum(penalty)) %>% 
  ungroup() %>% 
  mutate(pop_moved = rpois(nrow(.), lambda))

#new method
weights_pre <- weights %>%
  left_join(families_pre_town, by = "moved_from") %>% 
  left_join(dev_town, by = "moved_to") %>% 
  left_join(dist_0, by = c("moved_from", "moved_to")) %>% 
  #replace zero-length distances with replacements (half of max distance w/in town)
  mutate(dist_new = if_else(distance == 0, replace, distance)) %>% 
  #group by town pre-move
  group_by(moved_from) %>% 
  #round up units to integer
  mutate(prop_units = `Units Needed`/sum(`Units Needed`)) %>%
  #take inverse of distance squared
  mutate(inv_sq = 1/dist_new^2) %>% 
  #calculate crude penalty using families (pre-move town), proportion of new units (post-move town), and inverse distance squared (town pair)
  mutate(penalty = prop_units*inv_sq) %>% 
  mutate(lambda = penalty/sum(penalty)) %>% 
  ungroup()

#create new dataframe of weights for post-simulation population movement
weights_post <- weights_pre %>% 
  #arrange by starting town
  arrange(moved_from) %>% 
  #create column for population moved in each town pair
  mutate(pop_moved = 0)

#draw population moved from binomial distribution
for(j in 0:168) {
  weights_post$pop_moved[169*j+1] <- rbinom(1, size = weights_post$total_at_or_below_ami[169*j+1], prob = weights_post$lambda[169*j+1])
  for(i in 2:169) {
  weights_post$pop_moved[169*j+i] <- rbinom(1, size = weights_post$total_at_or_below_ami[169*j+i] - sum(weights_post$pop_moved[(169*j+1):169*j+i]), prob = weights_post$lambda[169*j+i])
  }
}

  
#view table
head(weights)

#check totals for consistency
sum(weights$prop_units[weights$moved_from == "Ansonia"]) #should sum to 1

sum(weights_pre$lambda[weights$moved_from == "Ansonia"]) #should sum to pre-move pop in Ansonia
weights$total_at_or_below_ami[weights$moved_from == "Ansonia"][1] #pre-move pop in Ansonia

sum(weights$pop_moved[weights$moved_from == "Ansonia"]) #total families moved out of Ansonia, should be no more than pre-move pop

sum(weights$pop_moved) #total families drawn to move or stay, should be no more than total families across all towns
sum(weights$total_at_or_below_ami[weights$moved_to == "Ansonia"]) #should equal total families across all towns
sum(low_income_pop$total_at_or_below_ami) #total families across all towns

```

```{r summarize movement of families}
#summarize families moved out by town
moved_out <- weights %>% 
  group_by(moved_from) %>% 
  summarize(pop_pre = mean(total_at_or_below_ami), moved_out = sum(pop_moved)) %>% 
  rename(TOWN_NAME = moved_from)

#summarize families moved in by town
moved_in <- weights %>% 
  group_by(moved_to) %>% 
  summarize(moved_in = sum(pop_moved)) %>% 
  rename(TOWN_NAME = moved_to)

#join moved_out and moved_in by town
pop_town_moved <- moved_out %>% 
  left_join(moved_in, by = "TOWN_NAME") %>% 
  #subtract families moved out and add families moved in by town
  mutate(pop_post = pop_pre + moved_in - moved_out)

#join to town polygon
towns_moved <- town_polygon %>% 
  left_join(pop_town_moved, by = "TOWN_NAME")

# check that total families moved in and moved out match
sum(pop_town_moved$moved_out)
sum(pop_town_moved$moved_in)

# check that total families pre and post match - value should match low-income estimate
sum(pop_town_moved$pop_pre)
sum(pop_town_moved$pop_post)
sum(low_income_pop$total_at_or_below_ami)
```

```{r map population by town pre and post move}
# map families by town pre-move
ggplot() + geom_sf(data = towns_moved, aes(fill = pop_pre)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map families by town post-move
ggplot() + geom_sf(data = towns_moved, aes(fill = pop_post)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map families moving out or staying
ggplot() + geom_sf(data = towns_moved, aes(fill = moved_out)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map families moving in or staying
ggplot() + geom_sf(data = towns_moved, aes(fill = moved_in)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)
```

```{r estimate change in incidence}

#assign dose-response relationships / health impact functions
##all-cause mortality and PM2.5 - PLACEHOLDER, MADE UP
dr_pm_allcause <- 0.0129 #1.29% increase in all-cause mortality per 1 ug/m3 increase in PM2.5

##all-cause mortality and O3

##all-cause mortality and NO2

##all-cause mortality and temperature

#estimate change in exposure and incidence
post_sim <- weights %>% 
  select(TOWN_NAME = moved_from, moved_to, pop_moved) %>% 
  #join mean PM2.5 by town pre-move
  left_join(pm_town[,1:2], by = "TOWN_NAME") %>% 
  rename(pm_pre = pm_mean, moved_from = TOWN_NAME, TOWN_NAME = moved_to) %>% 
  #join mean PM2.5 by town post-move
  left_join(pm_town[,1:2], by = "TOWN_NAME") %>% 
  rename(pm_post = pm_mean, moved_to = TOWN_NAME) %>% 
  #calculate difference (post-pre) in PM2.5 exposure
  mutate(pm_diff = pm_post - pm_pre) %>% 
  #join baseline all-cause mortality rates (per 100,000, currently using statewide)
  mutate(mr_pre = allcause$Crude.Rate[1]) %>% 
  #join dose-response relationships / health impact functions (PM2.5 and all-cause mortality)
  mutate(hif = dr_pm_allcause) %>% 
  #calculate post-move mortality rates using health impact function
  mutate(mr_post = mr_pre/(1 + dr_pm_allcause)^(pm_diff)) %>% 
  #calculate absolute difference in mortality rates (post-pre)
  mutate(mr_diff = mr_post - mr_pre) %>% 
  #calculate deaths averted (each family assumed to have 4 individuals)
  mutate(averted = -mr_diff*pop_moved/100000*4)
  
#sum total number of deaths averted
sum(post_sim$averted)

```

\newpage

**To-do/to-figure-out**
* Send list of health endpoints and ideas for identifying stratified dose-response relationships
  + Fill table shells with race/ethnicity-specific (and age-specific?) d-r coefficients
* assign var name from tidycensus
* Should we randomize family size? Or use average family size specific to each town?
* Better way to aggregate tracts into towns (also need to check if 2019 tracts = 2010 tracts)?
    + Best way to deal with tracts containing/contained in multiple townships? Specifically three tracts with 0 families, should I split into multiple observations so pollution estimate can be input into town average?
    + could do daziemetric (?) mapping - reapportioning census data into buildings, can take volume of building - going to be conservative, dilutive effect
    + for now, go with what I have, can circle back later
* Mean vs median to average pollution exposure across census tracts when aggregating to towns?
    + two options - can do aerial averaging - taking weighted avg by how much tract represents of each town - sf - st_intersection will give proportion that polygon comprises of another polygon
    + can complicate more later
    + find out what averaging EPA uses for FAQSD estimates - e.g. pop weighted or aerial avg
* Identify/quantify all-cause mortality endpoints and dose-response relationships (refer to BenMAP)
* Verify - we only need to simulate movement and calculate exposure/incidence changes for this specific population right? Since others not in this population are presumed to stay in place? Is it worth adding random movement of all CT residents?
* Percent affordable based on total assisted units / total units - total assisted currently includes government assisted, tenant rental assistance, SF CHFA USDA mortgages, and deed restricted units - good definition?
* Add inverse distance weighting penalty to movement simulation
    + check demography lit to justify squaring distance and standardizing
    + how to prevent drawing more families than estimate (pop_post is negative)
* Crude vs. age-adjusted (or otherwise adjusted) incidence rates?
* Where to get incidence rates specific to population?
    + use state incidence rate instead
* Simulate movement using total affordable units instead of units needed?
    + no, keep using units needed (new housing will drive movement)
* Start flow diagram/documentation of decision points
* Edit all-cause mortality dataframe and edit code for estimating change in mortality
* Should we use migration flows from Census data to estimate baseline probabilities of movement?
    + characteristics available for 2011-2015 ACS flows: Age, Sex, Race, Hispanic origin
    + would these be worth using instead of or in addition to inverse distance weighting?
* Centroids
    + use population weighted centroids
    + use correct projection for calculating centroid distances
* Deriving estimate of deaths averted
    + how to use dose-response coefficient properly?? Use exposure difference as exponent or factor?

