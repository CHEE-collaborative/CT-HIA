---
title: "Health Impact Assessment of Affordable Housing Development in Connecticut"
output:
  html_document:
    df_print: paged
  word_document: default
---

```{r load packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(here)
library(ncdf4)
library(raster)
#library(rgeos)
#library(rgdal)
library(tidycensus)
library(daymetr)
```

```{r load pollutant datasets}
# read in PM2.5 daily average by census tract from EPA FAQSD
pm_tract <- read.delim(gzfile("2019_pm25_daily_average.txt.gz"), sep = ",") %>%
## include only Connecticut tracts - FIPS starting with 9
  filter(str_detect(`FIPS`, "^9")) %>% 
## include only index date - July 4, 2019
  filter(`Date` == "2019/07/04") %>% 
## format FIPS to match GEOID format used by tidycensus get_acs
  mutate(GEOID = str_pad(FIPS, 11, side = "left", pad = "0"))

# read in ozone daily 8-hour maximum by census tract from EPA FAQSD
o3_tract <- read.delim(gzfile("2019_ozone_daily_8hour_maximum.txt.gz"), sep = ",") %>%
## include only Connecticut tracts - FIPS starting with 9
  filter(str_detect(`FIPS`, "^9")) %>% 
## include only index date - July 4, 2019
  filter(`Date` == "2019/07/04") %>% 
## format FIPS to match GEOID format used by tidycensus get_acs
  mutate(GEOID = str_pad(FIPS, 11, side = "left", pad = "0"))

no2 <- nc_open("SurfaceNO2_0.0083deg_2019.nc")

```

```{r load affordable housing dataset}
# read housing data from CT Open Data
housing_town <- read.csv("Affordable_Housing_by_Town_2011-2022.csv") %>% 
  filter(`Year` == 2019) %>% 
  mutate(`At least 10%?` = cut(`Percent.Affordable`, breaks = c(0,9.99999,100),
  labels = c("No", "Yes"))) %>% 
  rename("TOWN_NAME" = "Town") %>% 
  mutate(`Units Needed` = (1-(`Percent.Affordable`/10))*`X2010.Census.Units`*(1/9))

# set units needed to 0 for towns already at or above 10% threshold
housing_town$`Units Needed`[housing_town$`At least 10%` == "Yes"] = 0
```

```{r load incidence datasets}
# read county-level all-cause mortality rates from CDC WONDER
allcause <- read.delim("Underlying Cause of Death, 2018-2021, Single Race (2).txt", sep = "\t")[1:8,-1]
```

```{r get list of ACS variables}
# list of ACS variable names for reference
vars <- load_variables(year = 2019, dataset = "acs5", cache = TRUE)
```

```{r load shapefiles and population data for CT census tracts}
options(tigris_use_cache = TRUE)

# get CT census tract polygon
ct_tracts <- get_acs(state = "CT", geography = "tract", variables = "B17013_002", geometry = TRUE, year = 2019) %>% 
## join PM2.5 data
  left_join(., pm_tract, by = "GEOID") %>% 
## join ozone data
  left_join(., o3_tract, by = "GEOID")
```

```{r load shapefiles for CT townships}
# read CT town lines
town_lines <- st_read("CT Town Lines/Town_Lines.shp")

# read CT town polygon
town_poly <- st_read("CT Vicinity Town Polygon/CT_Vicinity_Town_Polygon.shp") %>%
  filter(STATE_COD == "CT", is.na(TOWN_NAME) == FALSE) 
# join housing data by town - using inner over left join to exclude area of Long Island Sound
town_polygon <- town_poly %>% 
  inner_join(., housing_town, by = "TOWN_NAME")
```

```{r aggregate tract-level exposures by township}
# using spreadsheet from 2010 census tract to town conversion tool from CT Data Collaborative: https://tract2town.ctdata.org/
tract_town <- read.csv("Census_Tracts_with_Town_Names__2010_.csv") %>% 
## join families by tract to towns by tract
  mutate(GEOID = str_pad(GEOID, 11, side = "left", pad = "0")) %>% 
  right_join(ct_tracts, by = "GEOID") %>%
## clean rows - delete undefined township, for now keeping rows with no exposure data (East Lyme, Wolcott)
  filter(`Town` != "County subdivisions not defined") 

## clean rows - assign tracts with multiple towns and 0 families to one town
tract_town$Town[tract_town$Town == "East Granby, Windsor Locks, Suffield"] <- "East Granby"
tract_town$Town[tract_town$Town == "Groton, Ledyard"] <- "Groton"
tract_town$Town[tract_town$Town == "Norwalk, Darien, Greenwich, Stamford, Westport"] <- "Norwalk"

## assigning all 20 families in tract to Union, this is the only tract containing Union
tract_town$Town[tract_town$Town == "Stafford, Union"] <- "Union" 

## splitting "Canaan, Norfolk" estimate among both since both are only found in this tract
tract_town <- tract_town %>% bind_rows(slice(., which(tract_town$Town == "Canaan, Norfolk"))) 
tract_town$Town[tract_town$Town == "Canaan, Norfolk"] <- "Canaan"
tract_town$Town[nrow(tract_town)] <- "Norfolk"
tract_town$estimate[tract_town$Town == "Canaan"] <- floor(tract_town$estimate[642]/2)
tract_town$estimate[tract_town$Town == "Norfolk"] <- ceiling(tract_town$estimate[833]/2)

# summarize mean PM2.5 and standard deviation of tract-level estimates by town
pm_town <- tract_town %>%
  rename(`TOWN_NAME` = `Town`) %>% 
  group_by(`TOWN_NAME`) %>% 
  summarize(`Average PM2.5 (ug/m3)` = mean(`pm25_daily_average.ug.m3.`, na.rm = TRUE), `Standard Deviation (ug/m3)` = sd(`pm25_daily_average.ug.m3.`, na.rm = TRUE), `Min` = min(`pm25_daily_average.ug.m3.`, na.rm = TRUE), `Max` = max(`pm25_daily_average.ug.m3.`, na.rm = TRUE))

# summarize mean and standard deviation of tract-level ozone estimates by town
o3_town <- tract_town %>%
  rename(`TOWN_NAME` = `Town`) %>% 
  group_by(`TOWN_NAME`) %>% 
  summarize(`Average O3 (ppb)` = mean(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE), `Standard Deviation (ppb)` = sd(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE), `Min O3` = min(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE), `Max O3` = max(`ozone_daily_8hour_maximum.ppb.`, na.rm = TRUE)) 

# join to town polygon
pm_town_sf <- town_polygon %>% 
  left_join(pm_town, by = "TOWN_NAME")

o3_town_sf <- town_polygon %>% 
  left_join(o3_town, by = "TOWN_NAME")

# summarize families by town and join housing by town
pop_town <- tract_town %>% 
  group_by(`Town`) %>% 
  summarize(`Families Pre` = sum(`estimate`)) %>%
  rename(`TOWN_NAME` = `Town`) %>% 
  full_join(housing_town, by = "TOWN_NAME")
```

```{r map exposure contrast within townships}
# map PM2.5 standard deviation by town
ggplot() + geom_sf(data = pm_town_sf, aes(fill = `Standard Deviation (ug/m3)`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map ozone standard deviation by town
ggplot() + geom_sf(data = o3_town_sf, aes(fill = `Standard Deviation (ppb)`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map PM2.5 standard error by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = pm25_daily_average_stderr.ug.m3.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map ozone standard error by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = ozone_daily_8hour_maximum_stderr.ppb.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)
```

```{r map baseline pollution by census tract}
# map PM2.5 by census tract without town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = pm25_daily_average.ug.m3.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map PM2.5 by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = pm25_daily_average.ug.m3.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map O3 by census tract without town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = ozone_daily_8hour_maximum.ppb.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map O3 by census tract with town lines
ggplot() + geom_sf(data = ct_tracts, aes(fill = ozone_daily_8hour_maximum.ppb.)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map temperature by census tract

```

```{r map baseline housing by township}
# map percent of affordable housing units by town
ggplot() + geom_sf(data = town_polygon, aes(fill = `Percent.Affordable`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)

# map 8-30g exemptions by town
ggplot() + geom_sf(data = town_polygon, aes(fill = `At least 10%?`))
```

```{r map baseline population by census tract}
# map families below poverty level by census tract
ggplot() + geom_sf(data = ct_tracts, aes(fill = estimate)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map low-income population by census tract

# map rent burdened population by census tract

```

```{r map baseline incidence by census tract}
# map baseline incidence of heart disease mortality by census tract

```

```{r map baseline pollution by township}
# map PM2.5 by town
ggplot() + geom_sf(data = pm_town_sf, aes(fill = `Average PM2.5 (ug/m3)`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1)
```


# SIMULATION V1 - no IDW penalty

```{r simulate movement of families}
# simulate random movement into new units
pop_town <- pop_town %>% 
  mutate(`Moved In` = rpois(nrow(.), round(`Units Needed`, 0)))

# list towns pre-move by family (one row per family) and draw random sample (moving out) equal to number of families moved in
moved_out_from <- rep(pop_town$TOWN_NAME, times = pop_town$`Families Pre`) %>% 
  sample(sum(pop_town$`Moved In`), replace = FALSE) 

# summarize families moved out by town and join pop_town
pop_town_moved <- moved_out_from %>%
  data.frame() %>% 
  rename(`TOWN_NAME` = 1) %>% 
  group_by(`TOWN_NAME`) %>% 
  summarize(`Moved Out` = n()) %>% 
  full_join(pop_town, by = "TOWN_NAME")

# replace NA's for number moved out with 0's (towns not drawn in sample of families)
pop_town_moved$`Moved Out`[is.na(pop_town_moved$`Moved Out`)] <- 0

# subtract families moved out and add families moved in to initial estimate for final estimate
pop_town_moved <- pop_town_moved %>% 
  mutate(`Families Post` = `Families Pre` + `Moved In` - `Moved Out`)

#join to town polygon
towns_moved <- town_polygon %>% 
  left_join(pop_town_moved, by = "TOWN_NAME")

# check that total families moved in and moved out match - value will vary with each simulation
sum(pop_town_moved$`Moved Out`)
sum(pop_town_moved$`Moved In`)

# check that total families pre and post match - value should match Census estimate
sum(pop_town_moved$`Families Pre`)
sum(pop_town_moved$`Families Post`)
sum(ct_tracts$estimate)
```

```{r map population by town pre and post move}
# map families by town pre-move
ggplot() + geom_sf(data = towns_moved, aes(fill = `Families Pre`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map families by town post-move
ggplot() + geom_sf(data = towns_moved, aes(fill = `Families Post`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map families moving out or staying
ggplot() + geom_sf(data = towns_moved, aes(fill = `Moved Out`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)

# map families moving in or staying
ggplot() + geom_sf(data = towns_moved, aes(fill = `Moved In`)) + 
  scale_fill_viridis_c(option = "magma", direction = -1) + geom_sf(data = town_lines)
```

```{r estimate change in incidence}
# assign baseline incidence by town
ischemic_town <- town_polygon %>%
  select(`CNTY_NAME`, `TOWN_NAME`) %>% 
  left_join(ischemic, by = "CNTY_NAME") %>%
  group_by(`TOWN_NAME`) %>% 
  summarize(`IHD` = mean(`Crude.Rate`))

# assign dose-response relationships / health impact functions
## ischemic heart disease and PM2.5 - PLACEHOLDER, MADE UP
dr_pm_ischemic <- 0.08 # 8% decrease in IHD mortality per 10 ug/m3 decrease in PM2.5

## ischemic heart disease and O3
## others


# list towns post-move by family moved (one row per family moved)
moved_in_to <- rep(pop_town$TOWN_NAME, times = pop_town$`Moved In`)

# combine towns pre-move by family and towns post-move by family to assign pre- and post- location to each family
town_moved_pre_post <- data.frame(moved_out_from, moved_in_to) %>%
## join pre-move exposure
  rename(`TOWN_NAME` = `moved_out_from`) %>% 
  left_join(pm_town, by = "TOWN_NAME") %>%
  ## join pre-move incidence rates
  left_join(ischemic_town, by = "TOWN_NAME") %>% 
## join post-move exposure
  select(`moved_out_from` = `TOWN_NAME`, `TOWN_NAME` = `moved_in_to`, `PM2.5 Pre` = `Average PM2.5 (ug/m3)`, `IHD Pre` = `IHD`) %>%
  left_join(pm_town, by = "TOWN_NAME") %>%
  select(`moved_out_from`, `moved_in_to` = `TOWN_NAME`, `PM2.5 Pre`, `PM2.5 Post` = `Average PM2.5 (ug/m3)`, `IHD Pre` = `IHD Pre`) %>% 
## calculate change in exposure
  mutate(`Change in PM2.5 (ug/m3)` = `PM2.5 Post` - `PM2.5 Pre`) %>% 
  mutate(`% Change in IHD` = `Change in PM2.5 (ug/m3)`/10*dr_pm_ischemic) %>% 
  mutate(`IHD Post` = `IHD Pre`*(1 +`% Change in IHD`)) %>% 
  mutate(`IHD Post - Pre` = `IHD Post` - `IHD Pre`)

# add total cases prevented - rate per 100,000 people, each family assumed to have 4 individuals 
sum(town_moved_pre_post$`IHD Post - Pre`)/100000*4

```

# SIMULATION V2 - Trying IDW penalty

```{r simulate movement with inverse distance weighting penalty}
#find centroids for largest polygon per town
centroids <- town_poly %>%
  st_centroid() %>% 
  group_by(TOWN_NAME) %>% 
  slice_max(order_by = SHAPE_Area)

distances <- centroids %>% 
  st_distance()

# assign weights to each pair of towns equal to inverse distance squared
weights <- data.frame(moved_from = rep(pop_town$TOWN_NAME, times = nrow(pop_town))) %>% 
  mutate(moved_to = rep(pop_town$TOWN_NAME, times = rep(169,169))) %>%
  mutate(geo_from = centroids$geometry[centroids$TOWN_NAME == weights$moved_from]) %>% 
  mutate(geo_to = centroids$geometry[centroids$TOWN_NAME == weights$moved_to])

  
  mutate(distance = st_distance(x = centroids$geometry[centroids$TOWN_NAME == weights$moved_from], y = centroids$geometry[centroids$TOWN_NAME == weights$moved_to], by_element = TRUE))

#find distance between town centroids

gDistance(town_polygon, byid = TRUE)

moved_out_from <- rep(pop_town$TOWN_NAME, times = pop_town$`Families Pre`)

```



